import { supabase } from '../supabaseClient';
import { calculateNextReview } from '../utils/sm2';

/**
 * Progress Service - Manages user learning progress in Supabase
 * Target Table: user_progress
 */

/**
 * Fetch user's progress for a specific deck
 * @param {string} userId - User ID from auth
 * @param {string} deckId - Deck ID (e.g., 'hsk1', 'hsk2')
 * @returns {Promise<Array>} Array of progress records
 */
export const getUserProgress = async (userId, deckId) => {
    try {
        const { data, error } = await supabase
            .from('user_progress')
            .select('*')
            .eq('user_id', userId)
            .eq('deck_id', deckId);

        if (error) throw error;
        return data || [];
    } catch (error) {
        console.error('Error fetching user progress:', error);
        return [];
    }
};

/**
 * Save or update word progress
 * @param {string} userId - User ID
 * @param {string} deckId - Deck ID
 * @param {string} wordId - Word ID
 * @param {Object} progressData - Progress data generated by sm2.js
 * @returns {Promise<Object>} Updated progress record
 */
export const saveWordProgress = async (userId, deckId, wordId, progressData) => {
    try {
        // Ensure we are only sending fields that exist in the database
        const payload = {
            user_id: userId,
            deck_id: deckId,
            word_id: wordId,
            status: progressData.status,
            ease_factor: progressData.ease_factor,
            interval: progressData.interval,
            repetitions: progressData.repetitions,
            step_index: progressData.step_index,
            next_review_at: progressData.next_review_at,
            last_reviewed_at: progressData.last_reviewed_at,
            updated_at: new Date().toISOString()
        };

        const { data, error } = await supabase
            .from('user_progress')
            .upsert(payload, {
                onConflict: 'user_id,deck_id,word_id'
            })
            .select()
            .single();

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error saving word progress:', error);
        throw error;
    }
};

/**
 * Get cards that are due for review immediately (Database Inquiry)
 * This is useful for pre-fetching or checking server-side state
 * @param {string} userId 
 * @param {string} deckId 
 */
export const getDueCardsDB = async (userId, deckId) => {
    try {
        const now = new Date().toISOString();
        const { data, error } = await supabase
            .from('user_progress')
            .select('word_id')
            .eq('user_id', userId)
            .eq('deck_id', deckId)
            .lte('next_review_at', now);

        if (error) throw error;
        return data?.map(item => item.word_id) || [];
    } catch (error) {
        console.error('Error fetching due cards from DB:', error);
        return [];
    }
};

/**
 * Sync local progress to database (Migration utility)
 */
export const syncLocalProgressToDatabase = async (userId, deckId, localVocab) => {
    // This function is less relevant now with strict DB architecture 
    // but kept for compatibility, updated to use correct columns
    try {
        const progressRecords = localVocab
            .filter(word => word.repetitions > 0 || word.status)
            .map(word => ({
                user_id: userId,
                deck_id: deckId,
                word_id: word.id,
                status: word.status || 'new',
                ease_factor: word.easinessFactor || 2.5,
                interval: word.interval || 0,
                repetitions: word.repetitions || 0,
                step_index: word.step_index || 0,
                next_review_at: word.nextReview || new Date().toISOString(),
                last_reviewed_at: new Date().toISOString()
            }));

        if (progressRecords.length === 0) return;

        const { error } = await supabase
            .from('user_progress')
            .upsert(progressRecords, {
                onConflict: 'user_id,deck_id,word_id'
            });

        if (error) throw error;
        console.log(`âœ… Synced ${progressRecords.length} words to database`);
    } catch (error) {
        console.error('Error syncing local progress:', error);
    }
};

/**
 * Get statistics for a deck
 * @param {string} userId - User ID
 * @param {string} deckId - Deck ID
 * @returns {Promise<Object>} Stats object with counts
 */
export const getDeckStats = async (userId, deckId) => {
    try {
        const progress = await getUserProgress(userId, deckId);

        // If no progress data, return zeros
        if (!progress || progress.length === 0) {
            return { total: 0, new: 0, learning: 0, reviewing: 0, mastered: 0, due: 0 };
        }

        const stats = {
            total: progress.length, // This is total *interacted* cards
            new: progress.filter(p => p.status === 'new').length,
            learning: progress.filter(p => p.status === 'learning' || p.status === 'relearning').length,
            reviewing: progress.filter(p => p.status === 'reviewing').length,
            mastered: progress.filter(p => p.status === 'mastered').length,
            due: progress.filter(p => {
                if (!p.next_review_at) return false;
                return new Date(p.next_review_at) <= new Date();
            }).length
        };

        return stats;
    } catch (error) {
        console.warn('Database not available for stats, using fallback:', error.message);
        return { total: 0, new: 0, learning: 0, reviewing: 0, mastered: 0, due: 0 };
    }
};

/**
 * Get all due cards for review (Legacy wrapper for compatibility)
 * @param {string} userId - User ID
 * @param {string} deckId - Deck ID
 * @returns {Promise<Array>} Array of word IDs that are due for review
 */
export const getDueCards = async (userId, deckId) => {
    return getDueCardsDB(userId, deckId);
};

/**
 * Fetch user's personal decks
 * @param {string} userId - User ID
 * @returns {Promise<Array>} Array of personal decks
 */
export const getPersonalDecks = async (userId) => {
    try {
        const { data, error } = await supabase
            .from('personal_decks')
            .select('*')
            .eq('user_id', userId)
            .order('created_at', { ascending: false });

        if (error) throw error;
        return data || [];
    } catch (error) {
        console.error('Error fetching personal decks:', error);
        return [];
    }
};

/**
 * Create a new personal deck
 * @param {string} userId - User ID
 * @param {Object} deckData - Deck data (title, description, words)
 * @returns {Promise<Object>} Created deck
 */
export const createPersonalDeck = async (userId, deckData) => {
    try {
        const { data, error } = await supabase
            .from('personal_decks')
            .insert({
                user_id: userId,
                ...deckData,
                created_at: new Date().toISOString()
            })
            .select()
            .single();

        if (error) throw error;
        return data;
    } catch (error) {
        console.error('Error creating personal deck:', error);
        throw error;
    }
};
